# B+트리

B+트리는 B-트리와 유사하지만 몇가지 차이점이 존재합니다. 실제 DB의 인덱싱은 B+트리로 이루어져있다고 합니다. 

![index](https://github.com/Ahrang777/Ahrang777.github.io/assets/59478159/f3b0490f-6e6b-4b31-bcb7-76b2b958ead2)



인덱싱을 B+트리로 나타내면 아래 그림과 같습니다. 

![B+tree](https://github.com/Ahrang777/Ahrang777.github.io/assets/59478159/f7780331-2867-4c5e-a50c-d9945e42d296)





## B-트리와의 차이점

1. **모든 key, data가 리프 노드에 모여있습니다.** 
   - B트리는 리프노드가 아닌 각 key마다 data를 갖는다면 B+트리는 리프노드에 모든 data를 갖습니다.
2. **모든 리프노드가 연결리스트 형태입니다.**
   - B-트리는 옆에 있는 리프노드를 검사할때, 다시 루트노드부터 검사해야 하지만 B+트리는 리프노드가 연결리스트로 서로 연결되어 있기에 선형검사를 수행할 수 있어 시간복잡도가 줄어듭니다. 
3. **리프노드의 부모 key는 리프노드의 첫번째 key보다 작거나 같습니다.** 그림의 B+트리는 리프노드의 key들을 트리가 가지고 있는 경우여서, data 삽입 또는 삭제가 일어날 때 트리의 key에 변경이 일어납니다. 해당 경우뿐만 아니라 data의 삽입과 삭제가 일어날 때 트리의 key에 변경이 일어나지 않게 하여 더욱 편하게 B+트리를 구현하는 방법도 존재하기 때문에 **작거나 같다**라는 표현을 사용하였습니다.
   - 화살표 방향을 생각했을때 노드기준은 오른쪽이 앞, 노드 내부 키 기준으로는 왼쪽이 앞



## 특징

- 노드는 최대 M개에서 M/2개의 자식을 가질 수 있습니다. 
- 노드에서 최대 M - 1개에서 M/2 - 1개의 키를 포함할 수 있습니다. 
- 즉, 노드의 키가 X개 라면 자식의 수는 X+1개 입니다. 
- 이진탐색 트리 처럼 각 key의 왼쪽은 항상 key보다 작은 값을 갖고 오른쪽은 큰 값을 갖습니다. 




## 키 검색

B-트리와 동일



## 키 삽입

삽입할 노드를 찾는 검색과정은 B-트리와 동일합니다. 삽입 과정도 B-트리와 유사하지만 약간의 차이가 있습니다.



#### 1. 분할이 일어나지 않고 삽입 위치가 리프노드의 가장 앞 key 자리가 아닌 경우

B-트리와 동일한 삽입과정



#### 2. 분할이 일어나지 않고, 삽입위치가 리프노드의 가장 앞 key 자리인 경우

삽입 후 부모 key를 삽입된 key로 갱신하고 data를 넣어줍니다.

![B+insert1](https://github.com/Ahrang777/Ahrang777.github.io/assets/59478159/255655ab-0361-497b-a103-f87dfb793abf)



#### 3. 분할이 일어나는 삽입과정

1. 분할이 일어나는 노드가 리프노드가 아니라면 기존 B-트리와 똑같이 분할을 진행합니다. 중간 key를 부모 key로 올리고, 분할한 두개의 노드를 왼쪽, 오른쪽 자식으로 설정합니다.
2. **분할이 일어나는 노드가 리프노드라면 중간 key를 부모 key로 올리지만, 오른쪽 노드에 중간 key를 포함하며 분할합니다.** 또한 리프노드는 연결리스트이기 때문에 왼쪽 자식노드와 오른쪽 자식노드를 이어줘 연결리스트 형태를 유지합니다. 

![B+insert2](https://github.com/Ahrang777/Ahrang777.github.io/assets/59478159/b7553248-54e4-4612-8a8c-427f8256eb83)



![B+insert3](https://github.com/Ahrang777/Ahrang777.github.io/assets/59478159/c3b2b964-5b25-49d2-acbe-514acb63fa4a)





## 키 삭제

삭제과정 역시 기존 B-트리와 유사하지만 삭제할 key 인 k가 무조건 리프노드에 존재하고 k를 삭제하기 위해 검색하는 과정에서 index에 존재할 수 있다는 점이 다릅니다. 즉, k는 리프노드에 존재하고 k가 부모노드(인덱스) 상에 존재할 수 있습니다.



#### 1. 삭제할 key k가 index에 없고, 리프노드의 가장 처음 key가 k가 아닌 경우

기존 B-트리와 삭제과정이 동일합니다. 

![B+delete1](https://github.com/Ahrang777/Ahrang777.github.io/assets/59478159/57c28f08-c821-446f-8c98-d70289701acd)



#### 2. 삭제할 key k가 리프노드의 가장 처음 key인 경우

이 경우 k는 항상 index 내에 존재합니다. 

1. 먼저 리프노드의 k를 삭제하는 과정을 수행합니다. key의 개수가 최소 key의 개수라면 B-트리의 삭제 과정 중 형제노드의 key를 빌려오는 경우나 부모 key와 병합하는 등 과정들은 동일하게 수행합니다. 단, 리프노드가 병합할 때는 부모 key와 오른쪽 자식의 처음 key가 동일하기 때문에 부모 key를 가져오는 과정만 생략하고 왼쪽 자식과 오른쪽 자식을 병합만 하면 됩니다. 
2. 리프노드와 k를 삭제한 후, index내의 k를 inorder successor로 변경합니다. 



![B+delete2](https://github.com/Ahrang777/Ahrang777.github.io/assets/59478159/70124721-9d87-490e-aec1-096030503f4f)



![B+delete3](https://github.com/Ahrang777/Ahrang777.github.io/assets/59478159/70223acb-8143-4ede-8eee-ad7308d7d97b)







참고

[https://velog.io/@emplam27](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Plus-Tree)

