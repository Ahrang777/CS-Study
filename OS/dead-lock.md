## Deadlock(=교착상태) 개념

첫 번째 스레드는 두 번째 스레드가 들고 있는 객체의 락이 풀리길 기다리고 있고, 두 번째 스레드 역시 첫 번째 스레드가 들고 있는 객체의 락이 풀리길 기다리는 상황
따라서 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하고 무한히 다음 자원을 기다리게 되는 상태를 **Deadlock** 에 빠졌다고 한다.

## Deadlock 발생 조건

> 네 가지 모두 성립해야 Deadlock이 발생한다.

1. 상호 배제(mutual exclusion)
   한 번에 한 프로세스만 공유 자원을 사용할 수 있다. 즉, 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다,
2. 점유 대기(hold and wait)
   자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
3. 비선점
   한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없다.
4. 순환 대기
   두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다.

## Deadlock의 처리 방법

> Deadlock의 처리 방법은 크게 3가지로 분류할 수 있다.

1. 데드락이 발생하지 않도록 `예방`하기
2. 데드락 발생 가능성을 인정하면서 적절하게 `회피`하기
3. 데드락 발생을 허용하지만 데드락을 `탐지`하여, 데드락에서 `회복`하기

## 예방(Prevention)

> 데드락의 발생조건 4가지 중 하나라도 발생하지 않게 하는 것. 즉, 각각의 조건을 방지(부정)하여 데드락 발생 가능성을 차단한다.

- 자원의 상호 배제 조건 방지: 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 한다.
  -> 추후에 동기화 관련 문제가 발생할 수 있다.
- 점유 대기 조건 방지: 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류하여 나중에 또 다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 한다.

- 비선점 조건 방지: 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 때, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 한다.

- 순환 대기 조건 방지: 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 한다.

=> 공유 자원 중 많은 경우가 한 번에 한 프로세스만 사용할 수 있기 때문에 사실상 1번 조건은 제거하기 어렵다. 따라서 대부분의 교착상태 방지 알고리즘은 4번 조건, 즉 대기 상태의 사이클이 발생하는 일을 막는데 초점이 맞춰져 있다.

## 회피(Avoidance)

> 교착 상태가 발생하기 전에 교착 상태를 예상하여 안전한 상태(safe state)에서만 자원 요청을 허용하는 방법이다.

- Safe state : Safe sequence가 존재하여 모든 프로세스가 정상적으로 종료할 수 있는 상태를 말한다.
  (Safe sequence: 교착 상태를 발생 시키지 않고 자원을 할당하는 순서)
- Unsafe state : 교착상태가 될 수 있는 상태, 하지만 불안정 상태라고 반드시 교착상태가 발생하는 것은 아니다. (불안정 상태가 교착 상태보다 좀 더 큰 집합)

이처럼 회피 알고리즘은 자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 허용하자는 것이 기본 특징이다.

이러한 특징을 살린 알고리즘에 `은행원 알고리즘`, `자원 할당 그래프 알고리즘` 이 있다.

### 은행원 알고리즘

은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래했다.

프로세스 시작 시 자신이 필요한 각 자원의 최대 개수를 미리 선언하고, 각 프로세스에서 자원 요청이 있을 때 요청을 승인하면 시스템이 Safe state로 유지되는 경우에만 자원을 할당한다.
그리고 불안정 상태가 예상되면 다른 프로세스가 끝날 때까지 대기하는 방법으로 데드락을 피해나간다.

하지만 은행원 알고리즘의 경우, 미리 최대 자원 요구량을 알아야 하고, 할당할 수 있는 자원 수가 일정해야 하는 등의 현실적인 제약조건이 많다.

### 자원 할당 그래프 알고리즘

자원과 프로세스에 대해 요청 간선과 할당 간선을 적용하여 교착 상태를 회피하는 알고리즘이다.

프로세스가 자원을 요구했을 때, 요청 간선을 할당 간선으로 변경 했을 시 사이클이 생성되는지 확인한다.
이때 사이클이 생성된다고 하여 무조건 교착상태인 것은 아니고, 자원에 하나의 인스턴스만 존재할 때 `교착 상태`로 판별한다. 그리고 자원에 여러 인스턴스가 존재하면 `교착 상태 가능성`으로 판별한다.
사이클을 생성하지 않으면 자원을 할당한다.

## 탐지(Detection) 및 회복(Recovery)

> 시스템이 예방이나 회피법을 사용하지 않았을 때, 데드락이 발생할 수 있으므로 데드락을 탐지하고 회복하는 알고리즘을 사용한다.

### 탐지 기법

Allocation, Request, Available 등으로 시스템에 데드락이 발생했는지 여부를 탐색한다. 즉, 은행원 알고리즘이나 자원 할당 그래프 방식과 비슷하게 현재 시스템의 자원 할당 상태를 가지고 파악한다.

> - Available: 각 형태별로 사용 가능한 자원 수(사용 가능량)을 표시하는 길이가 m 인 벡터
> - Allocation: 현재 각 프로세스에 할당되어 있는 각 형태의 자원 수(현재 할당량)을 정의하는 n\*m 행렬이다. Allocation[i, j]= k이면, 프로세스 Pi는 자원 Rj를 k개 할당 받고 있다는 의미이다.
> - Request: 각 프로세스의 현재 요청을 표시하는 n\*m 행렬이다. Reques[i,j]일 때 프로세스 Pi에 필요한 자원의 수가 k라면, 프로세스 Pi는 자원 Ri의 자원을 k개 더 요청한다.

### 회복 기법

탐지 기법을 통해 데드락을 발견했다면, `순환 대기`에서 벗어나 `데드락으로부터 회복`하기 위한 방법을 사용한다.

- 프로세스를 1개 이상 중단

  - 교착 상태에 빠진 `모든 프로세스를 중단`시키는 방법: 계속 연산 중이던 프로세스들도 모두 중단되어 부분 결과가 폐기 될 수 있는 부작용이 발생할 수 있다.
  - 프로세스를 `하나씩 중단시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복`시키는 방법: 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있다.

- 자원 섬점하기
  - 프로세스에서 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해주는 방법(해당 프로세스는 일시정지 시킴)
  - 우선 순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 프로세스 자원을 선점한다.
