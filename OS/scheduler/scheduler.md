# 스케줄러 ****(Scheduler)****

## 개념

![Untitled (4)](https://github.com/RIN-1011/RIN-1011/assets/60701386/4814cea4-059c-4d27-a33a-49d4184e9fef)

- 한정적인 메모리를 여러 프로세스가 효율적으로 사용할 수 있도록 **CPU에서 실행 가능한 여러 프로세스들 중에서 하나의 프로세스를 선택하는 역할**
- 다중 프로그래밍의 목적은 CPU 이용을 최대화하기 위하여 항상 어떤 프로세스가 실행되도록 함
- 시분할의 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU를 빈번하게 교체하는 것

※ 다중 프로그래밍 : 메모리에 여러 개의 프로그램을 상주 시켜서 하나의 CPU로 동시에 여러 프로그램을 실행하는 것처럼 처리하는 시스템

※ 시분할 : 여러 명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아가며 처리해줌으로써 각 사용자에게 독립된 컴퓨터를 사용하는 느낌을 주는 것

## 스케줄링 큐

- 작업 큐 (Job Queue) : 시스템 안의 모든 프로세스들로 구성
- 준비 큐 (ready queue) : 메인 메모리에 존재하며, 준비 완료 상태에서 실행을 대기하는 프로세스들로 구성
- 장치 큐(device queue) : 특정 입/출력장치를 대기하는 프로세스들의 리스트들로 구성

## 스케줄러 종류

### 장기 스케줄링 **(Long-term scheduling)**

- 어떤 프로세스를 준비 큐에 넣을 것인지 결정
    - 디스크에서 하나의 프로그램을 가져와 커널에 등록하면 프로세스가 되는데 이때 디스크에서 어떤 프로그램을 가져와 커널에 등록할지 결정
- 메모리에 동시에 올라가 있는 프로세스의 수를 조절함
- 수십 초 내지 수 분 단위로 가끔 호출되기 때문에 상대적으로 속도가 느림
- 현대 OS에는 일반적으로 장기 스케줄러 두지 않음
    - 과거 OS : 적은 양의 메모리를 많은 프로세스들에게 할당 → 프로세스당 메모리 보유량 적어짐 → 장기 스케줄러가 조절
    - 현대 OS : 프로세스 시작되면 장기 스케줄러 없이 바로 그 프로세스에 메모리 할당해 준비 큐에 넣어줌

### 중기 스케줄링 **(Middle-term scheduling)**

- 메모리에 적재된 프로세스 수 관리
    - 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러
- 차후 다시 프로세스를 메모리로 불러와서 중단되었던 지점에서 실행을 재개하는 스와핑 기능을 함

### 단기 스케줄링 **(Short-term scheduling)**

- 메모리 내의 준비 상태에 있는 작업 중 실행할 프로세스를 선택하여 CPU를 할당
- 일반적으로 스케줄러라 함은 단기 스케줄러를 의미
- 미리 정한 스케줄링 알고리즘에 따라 CPU를 할당할 프로세스를 선택
- ms 이하의 시간 단위로 매우 빈번하게 호출되기 때문에 수행 속도가 충분히 빨라야 함

# CPU 스케줄링

## 스케줄링 기준

![Untitled (5)](https://github.com/RIN-1011/RIN-1011/assets/60701386/fc9ac8a2-6ccd-4c81-9ace-415e3b5cb3eb)

- CPU 이용률 (CPU Utilization) → 최대화
    - 전체 시스템 시간 중 CPU가 작업을 처리하는 시간의 비율
- 처리량 (Throughput) → 최대화
    - CPU가 단위 시간당 처리하는 프로세스의 개수
- 총처리 시간 (Turnaround Time) → 최소화
    - 프로세스가 시작해서 끝날 때까지 걸리는 시간
    - 작업 종료 시간 - 도착 시간
- 대기 시간 (Waiting Time) → 최소화
    - 프로세스가 준비 큐 내에서 대기하는 시간의 총합
    - 마지막 작업 시작 시간 - 도착 시간
- 응답 시간 (Response Time) → 최소화
    - 시분할 시스템에서 요청 후 응답이 오기 시작할 때까지의 시간

## 비선점 스케줄링

### 개념

- 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없게 하는 기법

### 장점

- 순서대로 처리되므로 공정성 있음
- 다음에 처리해야 할 프로세스와 관계없이 응답 시간 예상 가능
- 선점 방식보다 스케줄러 호출 빈도 낮고 문맥 교환에 의한 오버헤드 적음
- 일괄 처리 시스템에 적합

### 단점

- 공정성은 갖췄지만 융통성은 없음
    - CPU 사용 시간 긴 하나의 프로세스가 CPU 사용 시간이 짧은 여러 프로세스를 대기시킬 수 있으므로 처리율 떨어질 수 있음

### 선입 선처리 스케줄링 (FCFS: **First Come First Served Scheduling**)

- **먼저 자원 사용을 요청한 프로세스에게 자원을 할당해주는 방식**
- 장기 스케줄러에서 사용가능(Batch 작업등)
- 수행 중인 긴 작업을 여러 개의 짧은 작업들이 기다리게 되는 호위(호송) 효과(Convoy Effect)의 문제가 발생한다.

![Untitled (6)](https://github.com/RIN-1011/RIN-1011/assets/60701386/f855a148-588c-4a83-acdf-4ab59b6da81f)

### 최단 작업 우선 스케줄링 (SJF : **Shortest Job First Scheduling**)

- **CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식**
- 두 개 이상의 프로세스의 점유 시간이 같다면 FCFS 방식으로 처리
- 평균 대기 시간에 있어 최적의 알고리즘

![Untitled (7)](https://github.com/RIN-1011/RIN-1011/assets/60701386/fa4c8f5a-349c-41e6-8a3e-00699df5176d)

[도착 시간 고려]

![Untitled (8)](https://github.com/RIN-1011/RIN-1011/assets/60701386/5ac7a760-a0b9-4ed1-8c60-aee3d350d76b)

### 우선순위 스케줄링 (Priority S**cheduling)**

- 각 프로세스의 우선순위가 정해지면, **우선순위가 제일 높은 프로세스에게 CPU를 할당하는 방식**
- 우선순위가 같은 경우에는 FCFS 방식을 적용
- ‘**기아(Starvation) 문제**’ 발생 : 우선순위가 높은 작업이 계속적으로 들어올 경우 우선순위가 낮은 작업은 준비 상태에서 보장 없이 머물게 됨
    - ‘에이징(Aging)’으로 해결 : 시스템에 머무는 시간이 증가할수록 우선순위를 높여주는 기법
- 우선순위 기준
    - 내부적 우선순위 고려 : 제한 시간, 메모리 요구량, 사용하는 파일 수, 평균 CPU Burst에 대한 평균 I/O Burst의 비율 등
    - 외부적 우선순위 고려 : 사용료, 정책적인 변수 등

![Untitled (14)](https://github.com/RIN-1011/RIN-1011/assets/60701386/8f352cb2-7d2f-46db-b2f0-5715e339bab0)

## 선점 스케줄링

### 개념

- 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법

### 장점

- 프로세스 하나가 장시간 동안 프로세서를 독점하려는 것을 방지하기 때문에 모든 프로세스에 프로세서를 서비스할 기회 늘릴 수 있음
- 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합하며 긴급한 프로세서를 제어할 수 있음

### 단점

- 오버헤드가 커질 수 있어 효과적으로 이용하려면, 메모리에 프로세스가 많이 적재되어 있어야 함
    - 프로세서를 사용 가능할 때마다 실행할 수 있는 프로세스들이 준비 상태에 있어야 효과적
- 우선순위를 의미 있게 부여하지 않으면 효과 없음

### SRTF **(Shortest Remaining Time Scheduling)**

- 최단 잔여시간을 우선으로 하는 스케줄링
- 선점형 SJF 스케줄링이라 불림

![Untitled (13)](https://github.com/RIN-1011/RIN-1011/assets/60701386/028e1484-fb4a-4646-8ff0-fbe16cce6ea2)

### 라운드 로빈 스케줄링 (RR : **Round Robin Scheduling**)

- 준비 큐를 원형 큐로 간주하고 순환식으로 각 프로세스에게 작은 단위의 시간량(타임 퀀텀)만큼씩 CPU를 할당하는 방식
- 알고리즘의 성능은 시간 할당량의 크기에 좌우됨
    - 시간할당량이 매우 크면 FCFS 스케줄링과 같아지며, 시간 할당량이 매우 작으면 프로세서 공유와 같아진다.
- 이론 상 n개의 프로세스가 1/n의 속도로 동시에 실행
- 일반적으로 평균 반환시간이 SJF보다 크지만, 프로세스가 공정하게 기회를 얻게 되어 기아상태가 발생하지는 않음
- 타임 퀀텀의 크기가 작으면 잦은 문맥 교환 오버헤드 증가로 처리율(Throughput)이 감소할 수 있으며 성능은 타임 퀀텀의 크기에 많은 영향을 받는다.

![Untitled (10)](https://github.com/RIN-1011/RIN-1011/assets/60701386/58e7e815-fce7-4c7c-9265-18198b76cf9b)

### 다단계 큐 스케줄링 (Multilevel Queue Scheduling)

- 우선순위마다 준비 큐 형성
- 항상 가장 높은 우선순위 큐의 프로세스에 CPU를 할당 (우선순위가 낮은 큐에서 작업 실행 중이더라도 상위 단계의 큐에 프로세스가 도착하면 CPU를 빼앗는 선점형 스케줄링)
- 각 큐는 라운드 로빈이나 FCFS등 독자적 스케줄링 사용 가능
- 대화형, 배치(Background)등의 프로세스 성격에 따라 우선순위 부여
- 큐들 간의 프로세스 이동이 불가하기 때문에 스케줄링 부담이 적지만 유연성이 떨어짐
- 우선순위가 낮은 프로세스가 오랫동안 CPU 할당을 기다리는 기아 현상이 발생할 수도 있음
- 
![Untitled (11)](https://github.com/RIN-1011/RIN-1011/assets/60701386/d4827f31-23a2-4380-8788-f12a67254da7)

### 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue Scheduling)

- 다 단계 큐 + 동적인 프로세스 우선 순위 변화 적용
- 프로세스 생성 시 가장 높은 우선 순위 준비 큐에 등록되며 등록된 프로세스는 FCFS 순서로 CPU를 할당받아 실행된다. 해당 큐의 CPU 시간 할당량(Time Quantum)이 끝나면 한 단계 아래의 준비 큐에 들어간다.
- 단계가 내려갈수록 시간 할당량(Time Quantum)이 증가한다.
- 큐 사이의 프로세스 이동 가능하며 CPU Burst는 낮은 우선순위의 큐, I/O Burst는 높은 우선순위의 큐에 배치한다.
- 가장 하위 큐는 FCFS 스케줄링
- 맨 아래 큐에서 너무 오래 대기하면 다시 상위 큐로 이동 (에이징 기법을 통한 기아상태 예방)

![Untitled (12)](https://github.com/RIN-1011/RIN-1011/assets/60701386/1a735287-9aa9-437b-927f-c2bf2a6c7061)

## 참고

[https://dheldh77.tistory.com/entry/운영체제-스케줄러Scheduler](https://dheldh77.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%ACScheduler)

[https://velog.io/@evergreen_tree/OS-스케줄러](https://velog.io/@evergreen_tree/OS-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC)

[https://velog.io/@ragnarok_code/OS-스케쥴러-Scheduler란](https://velog.io/@ragnarok_code/OS-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC-Scheduler%EB%9E%80)

https://dar0m.tistory.com/247

https://dar0m.tistory.com/250

https://cocoon1787.tistory.com/123
