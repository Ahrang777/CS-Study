# 메모리 관리 전략

> 제한된 물리 메모리의 효율적인 사용과 메모리 참조 방식을 제공하기 위한 전략

## 논리 vs 물리 주소 공간

<img src="https://github.com/Ahrang777/CS-Study/assets/72875528/b1dab74c-6608-4cbd-ba1e-3c5bf80e4734" width="60%" height="50%"/>

- CPU가 생성하는 주소 : 논리주소
- 메모리가 취급하는 주소 : 물리주소
- 프로그램 실행 중에서는 가상 주소를 물리 주소로 바꿔줘야 하는데 이 매핑 작업은 메모리 관리기(Memory Management Unit)에서 실행된다.
- 앞으로 다룰 기법들은 이러한 매핑 작업에 대해서 알아보는 것이다.

## 메모리 관리 정책

- 가져오기 정책(Fetch Policy) : 필요로 하는 데이터를 언제 메모리로 가져올지 결정
- 배치 정책(Placement Policy) : 가져온 데이터를 메모리 어느 위치에 올려놓을지 결정
- 교체 정책(Replacement Policy) : 어떤 데이터를 메모리에서 내보내고 가져올지 결정

## 가져오기 / 적재 (Fetch / Load)

- 요구 적재(Demand Fetch) : 요청 시 메모리에 적재
  - ex) 요구 페이징(Demand Paging) : 가상 메모리 기법
    - 프로그램 실행 시 프로세스를 구성하는 모든 페이지를 한꺼번에 메모리에 올리는 것이 아니라 당장 사용될 페이지만을 올리는 방식
- 예상 적재(Anticipatory Fetch) : 미리 예상하여 메모리에 적재
  - ex) 참조 가능성이 높은 페이지 미리 적재

## 배치 전략 (Placement)

> 새로 적재되어야 할 데이터를 주기억장치 영역 중 어느 곳에 배치할지를 결정하는 전략

- 최초 적합 전략(First-Fit Strategy)

  - 사용 가능한 공간을 검색하여 첫 번째로 찾아낸 곳을 할당하는 방식
  - 맨 앞(또는 지난번 탐색이 끝난 곳)에서부터 수용 가능한 첫 번째 공간을 선택

  |      |                                       |
  | ---- | ------------------------------------- |
  | 장점 | 가용 공간 정렬 불필요하다.            |
  | 단점 | 큰 공간을 쪼개어 사용하게 될 수 있다. |

- 최적 적합 전략(Best-Fit Strategy)
  - 사용 가능한 공간들 중에서 가장 작은 것을 선택하는 방식
  - 가용 공간을 정렬하여 필요한 크기 이상의 공간 중 가장 작은 것을 할당하는 방식
    | | |
    | ---- | -------------------------------- |
    | 장점 | 큰 공간을 쪼개어 쓰는 일이 적다. |
    | 단점 | 정렬이 필요하다. |
    | | 작은 틈새 공간이 많이 발생한다. |
- 최악 적합 전략(Worst-Fit Strategy)
  - 사용 가능한 공간들 중에서 가장 큰 것을 선택하는 방식
  - 가용 공간을 정렬하여 수용 가능한 공간 중 가장 큰 곳을 할당하는 방법
    | | |
    | ---- | ---------------------------------------- |
    | 장점 | 남은 공간이 크다. |
    | | 다른 프로세스가 유용하게 사용할 수 있다. |
    | 단점 | 정렬이 필요하다. |
    | | 공간 낭비가 발생한다. |

## 교체 (Replacement)

### 스와핑 (Swapping)

> 프로세스가 실행되기 위해서는 메모리에 있어야 하지만, 프로세스는 실행 중에 임시로 예비저장장치에 내보내졌다가 실행을 계속하기 위해 다시 메모리로 돌아올 수 있다. 이때 스와핑을 사용한다.

<img src="https://github.com/Ahrang777/CS-Study/assets/72875528/b4828237-7bbd-4107-a782-3efb046026b5" width="80%" height="50%"/>

1. 시스템은 실행 준비가 끝난 프로세스들을 준비 완료 큐에 대기시킨다.
2. CPU 스케쥴러는 다음 프로세스를 고를 때 Dispatcher(디스패처)를 호출한다.
3. Dispatcher는 이 큐에 있는 다음 프로세스가 메모리에 적재되어 있는지를 확인하고, 만약 올라와 있지 않다면 디스크에서 불러들어야 한다.
4. 만약 프로세스를 불러들이기 위한 공간이 메모리에 부족하다면 현재 메모리에 적재된 프로세스들을 내보내고(swap out) 원하는 프로세스를 불러들인다(swap in).
5. 그 후 CPU의 모든 레지스터를 실행해야 할 프로세스의 것으로 다시 적재 후 제어를 프로세스에게 넘긴다.

##### Dispatcher

<img src="https://github.com/Ahrang777/CS-Study/assets/72875528/a1758056-664d-4628-9ed6-7609b7674d76" width="60%" height="50%"/>

- 사용자가 프로그램을 실행하면 프로세스가 생성되고 Ready 상태가 된다.
- 그 후 스케쥴러가 Ready Queue에 있는 프로세스 중 하나를 프로세서(CPU)가 사용가능한 상태가 될 때 CPU를 할당해준다.
- 이를 Ready 상태에서 Running 상태로 상태전이된다고 하며, 이 과정을 디스패칭(Dispatching)이라한다.
- 그리고 디스패처(Dispatcher)가 이 일을 수행한다.

#### 기본 스와핑 문제점

- Context-Switching 발생한다.
- 스와핑을 위해서는 메모리의 프로세스가 완전히 휴지 상태(idle)임을 확인해야 한다.
- 입출력 장치에 관한 작업을 진행 중이라면 스와핑을 해선 안된다.

##### Context Switching

멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 교체하는 작업

#### 현재 운영체제에서의 스와핑

- 현재 운영체제들은 이러한 비효율성으로 기본 스와핑은 사용하지 않지만, 변형해서 사용하기도 한다.
- 평상시에는 작동하지 않다가, 자유 메모리가 임계량 보다 부족하게 될 경우 작동을 시작하는 경우도 있다.
- 프로세스 전체를 스와핑하지 않고, 일부만 스와핑 하여 Context-Switching time을 줄일 수도 있다.

## 메모리 관리 기법

1. 연속 메모리 기법
   - 프로그램 전체가 메모리에 연속적으로 할당
   - 고정 분할 기법 : 메모리가 고정된 파티션으로 불할. 내부 단편화 발생
   - 동적 분할 기법 : 파티션들이 동적으로 생성되고 자신의 크기와 같은 파티션에 메모리 할당. 외부 단편화 발생
2. 불연속 메모리 기법
   - 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
   - Page : 프로세스를 고정된 크기로 나눈 블록
   - Frame : 메모리를 고정된 크기로 나눈 블록
   - Segment : 서로 다른 크기의 논리적 블록

## 가상 메모리

> 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법

- 실제 메모리 크기와 관계없이 메모리를 사용할 수 있도록 가상 메모리 주소를 사용한다.
- 프로세스의 일부분만 메모리에 로드하고 나머지는 보조 기억 장치(가상 메모리 공간)에 할당한다.
- MMU(Memory Management Unit)을 통해 논리 주소, 물리 주소로 나누어서 사용한다.
- 가상 주소를 주기억장치의 실제적인 주소로 매핑하는 방법을 통해 구현한다.

### 페이징 (Paging)

<img src="https://github.com/Ahrang777/CS-Study/assets/72875528/1138ef3a-b749-4564-a556-7104e32c0ff7" width="80%" height="50%"/>

- 프로세스의 주소 공간을 고정된 사이즈의 페이지 단위로 나누어 물리적 메모리에 불연속적으로 할당하는 방식이다.
- 메모리를 Frame이라는 고정크기로 분할되고, 프로세스는 Page라는 고정크기로 분할된다.
- Page와 Frame은 크기가 같다.
- 페이지와 프레임을 대응시키는 Page Mapping 과정이 필요하며 Paging Table을 생성해야 한다.
- 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제를 해결할 수 있다.
- Paging Table에는 각 페이지 번호와 해당 페이지가 할당된 프레임의 시작 물리 주소를 저장한다.

- 단점
  - 프로세스의 크기가 페이지 크기의 배수가 아닌 경우, 마지막 페이지에 내부 단편화가 발생하가 페이지의 크기가 클수록 내부 단편화가 커진다.
    - 페이지 단위를 적게하여 내부 단편화 문제를 해결할 수 있지만, Page Mapping 과정이 많아져서 효율이 떨어진다.

#### 페이지 교체 기법

1. FIFO(First In First Out)
   - 가장 오래된 페이지를 Page-out하는 방식
   - 이 알고리즘을 수행하기 위해 각 페이지가 올라온 시간을 페이지에 기록하거나, 페이지가 올라온 순서를 큐에 정하는 방식으로 사용할 수 있다.
   - 장점
     - 이해가 쉽고, 구현이 간단하다.
   - 단점
     - 활발하게 사용 중인 페이지를 계속해서 교체한다면 페이지 부재율이 높아지고 실행 속도가 떨어질 위험이 있다.
2. 최적(Optimal) 페이지 교체
   - 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 방식
   - 앞으로 가장 오랫동안 사용되지 않을 페이지를 미리 알 방법이 없기에 구현 불가능한 알고리즘이다.
   - 장점
     - 페이지 교체수가 가장 적다.
   - 단점
     - 구현이 어렵다.
3. LRU(Least-Recently-Used)
   - 가장 오래 사용되지 않을 페이지를 교체하는 방식
   - 과거의 데이터를 바탕으로 페이지가 사용될 시간을 예측하여 교체한다.
   - 장점
     - 최적보다 교체횟수가 높지만 FIFO보다 효율적이다.
     - LRU 알고리즘은 많은 운영체제가 채택하는 알고리즘이며, 좋은 알고리즘으로 평가받고 있다.
4. 계수-기반 페이지 교체
   - 페이지 참조시마다 각 페이지가 현재까지 참조된 횟수를 카운팅하는 방식
   1. LFU(Least-Frequently-Used)
   - 참조 횟수가 가장 작은 페이지를 교체하는 방식
   2. MFU(Most-Frequently-Used)
   - 참조 횟수가 가장 많은 페이지를 교체하는 방식

### 세그멘테이션 (Segmentation)

<img src="https://github.com/Ahrang777/CS-Study/assets/72875528/cbdc14b6-38cd-4088-b0df-916412cd50b4" width="80%" height="50%"/>

- 프로세스를 서로 크기가 다른 논리적인 블록 단위인 세그먼트로 분할하여 메모리 할당한다.
- 각 세그먼트는 연속적인 공간에 저장된다.
- 세그먼트들의 크기가 서로 다르기 때문에 프로세스가 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다.
- 페이징과 마찬가지로 Mapping을 위한 Segment Table이 필요하다.
- 단점
  - 프로세스가 필요한 메모리 공간만큼 메모리를 할당해주기 때문에 내부 단편화 문제는 발생하지 않지만, 중간에 메모리를 해제하면 외부 단편화가 발생하게 된다.

## Paging vs Segmentation

| Paging                | Segmentation          |
| --------------------- | --------------------- |
| 고정 크기             | 가변 크기             |
| 내부 단편화 발생 가능 | 외부 단편화 발생 가능 |

## 참고

https://gooweon.tistory.com/183  
https://dduddublog.tistory.com/28  
https://www.crocus.co.kr/1406  
https://cocoon1787.tistory.com/860
