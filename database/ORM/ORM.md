# 목차
1. [영속성](#영속성)
2. [개념](#개념)
3. [객체-관계 간의 불일치](#객체-관계-간의-불일치)
4. [장단점](#장단점)
<br>

# ORM

## 영속성

- 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성
- 영속성을 갖지 않는 데이터는 단지 메모리에서만 존재하기 때문에 프로그램을 종료하면 모두 잃어버리게 됨
- **Object Persistence (영구적인 객체)**
    - 메모리 상의 데이터를 파일 시스템, 관계형 테이터베이스 혹은 객체 데이터베이스 등을 활용하여 영구적으로 저장하여 영속성 부여
    - 데이터를 데이터베이스에 저장하는 3가지 방법
        - JDBC (Java)
        - Spring JDBC (Ex. JDBC Template)
        - Persistence Framework (Ex. Hibernate, Mybatis 등)
- Persistence Layer
    - 프로그램의 아키텍처에서, 데이터에 영속성을 부여해주는 계층
    - JDBC를 이용하여 직접 구현할 수 있지만 Persistence framework를 이용한 개발이 많이 이루어짐
- Persistence Framework
    - JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와 연동되는 시스템을 빠르게 개발할 수 있으며 안정적인 구동을 보장
    - Persistence Framework는 **SQL Mapper**와 **ORM**으로 나눌 수 있음
        - Ex) JPA, Hibernate, Mybatis 등

## 개념

![Untitled](https://github.com/RIN-1011/RIN-1011/assets/60701386/b41701a8-b5b8-46f2-9034-2ce6dfa363fc)

- Object-Relational Mapping 즉, 객체와 관계형 데이터베이스 매핑의 줄임말이다.
- OOP(Object Oriented Programming)에서 쓰는 객체라는 개념을 구현한 클래스와 RDB(Relational DataBase)에서 쓰이는 데이터인 테이블을 매핑(연결)하는 것을 의미한다.
    - 객체 모델과 관계형 모델 간에 불일치 존재

## 객체-관계 간의 불일치

- 클래스와 테이블은 기존부터 호환가능성을 두고 만들어지지 않아 아래와 같은 불일치 발생
    
    → ORM을 통해 객체 간의 관계를 바탕으로 SQL문을 자동으로 생성하여 불일치 해결
    
    → 따라서 ORM을 이용하면 따로 SQL문을 작성할 필요 없이 객체를 통해 간접적으로 데이터베이스를 조작할 수 있음
    
<img width="610" alt="Untitled (1)" src="https://github.com/RIN-1011/RIN-1011/assets/60701386/b0515972-4d09-427e-9c3c-293c3a60d3c7">

- 상세 설명
    - **Granularity(세분성)**
        - 경우에 따라 데이터베이스에 있는 해당 테이블 수보다 더 많은 클래스를 가진 객체 모델을 가질 수 있다.
        - 예를 들어, “사용자 세부 사항”에 대해 생각해보자.
            - 코드 재사용과 유지보수를 위해 “Person”과 “Address”라는 두 개의 클래스로 나눌 수 있다.
            - 그러나 데이터베이스에는 person이라는 하나의 테이블에 “사용자 세부 사항”을 저장할 수 있다.
            - 이렇게 Object 2개와 Table 1개로 두 개의 갯수가 다를 수 있다.
    - **Inheritance(상속)**
        - RDBMS는 객체지향 프로그래밍 언어의 자연적 패러다임인 상속과 유사한 것을 정의하지 않는다.
        - 즉, 상속의 개념이 없다.
    - **Identity(일치)**
        - RDBMS는 ‘sameness’라는 하나의 개념을 정확히 정의하는데, 바로 ‘기본키(primary key)’이다.
        - 그러나 자바에서는 객체 식별(a==b)과 객체 동일성(a.equales(b))을 모두 정의한다.
        - RDBMS에서는 PK가 같으면 서로 동일한 record로 정의하지만, Java에서는 주솟값이 같거나 내용이 같은 경우를 구분하여 정의한다.
    - **Associations(연관성)**
        - 객체지향 언어는 객체 참조(reference)를 사용하는 연관성을 나타내는 반면, RDBMS는 연관성을 ‘외래키(foreign key)’로 나타낸다.
    - **Navigation(탐색/순회)**
        - Java 및 RDBMS에서 객체에 액세스하는 방법은 근본적으로 다르다.
        - Java에서는 하나의 연결에서 다른 연결로 이동하면서 탐색/순회한다. (그래프 형태)
            - 예를 들어, aUser.getBillingDetails().getAccountNumber()
            - 이는 RDBMS에서 데이터를 검색하는 효율적인 방법이 아니다.
        - RDBMS에서는 일반적으로 SQL 쿼리 수를 최소화하고 JOIN을 통해 여러 엔터티를 로드하고 원하는 대상 엔터티를 선택(select)한다.

## 장단점

### 장점

- **객체지향적인 코드로 인해 더 직관적이고 로직에 집중할 수 있도록 도와준다.**
    - SQL문이 아닌 클래스의 메소드를 통해 DB를 조작할 수 있으므로 개발자가 객체 모델만 이용해서 개발을 하는 데 집중할 수 있다.
    - 선언문, 할당, 종료 같은 부수적인 코드가 없거나 줄어든다.
    - 객체마다 코드를 별도로 작성하기 때문에 코드의 가독성이 높아진다.
    - SQL의 절차적이고 순차적인 접근이 아닌 객체지향적인 접근으로 인해 생산성을 높여준다.
- **재사용 및 유지보수의 편리성이 증가한다.**
    - ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용할 수 있다.
    - 매핑 정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다.
- **DBMS(Database Management System)에 대한 종속성이 줄어든다.**
    - 대부분 ORM 솔루션은 DB에 종속적이지 않기 때문에 구현 방법 뿐만 아니라 많은 솔루션에서 자료형 타입까지 유효하다. (종속성? 프로그램 구조가 데이터 구조에 영향을 받는지)
    - 개발자는 Object에 집중함으로 극단적으로 DBMS를 교체하는 큰 작업에도 적은 리스크와 시간이 소요된다.
    - 또한 자바에서 가공할 경우 equals , hashcode 의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠른 가공이 가능하다.

### 단점

- **완벽한 ORM으로만 서비스를 구현하기 어렵다.**
    - 사용하기는 편하지만 설계는 매우 신중하게 해야한다.
    - 프로젝트의 복잡성이 커질 경우 난이도 또한 올라갈 수 있다.
    - 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다.
    - 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는 등 별도의 튜닝이 필요한 경우가 있다.
        - SP: SQL 명령문들을 마치 하나의 함수처럼 사용하기 위해 DB 내부에 저장된 쿼리의 집합
- **프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.**
    - 이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 발생할 수 있다.
        - 프로시저: 절차형 SQL 을 활용하여 특정 기능을 수행할 수 있는 트랜잭션 언어

### SQL **Mapper VS ORM**

|  | 장점 | 단점 | 예시 |
| --- | --- | --- | --- |
| SQL Mapper | 1. JDBC를 사용할 때  발생하는 불편함을 줄일 수 있음<br>2. SQL이 비즈니스 로직과 분리되어 유지보수가 용이함<br>3. 세부적인 SQL 변경 시 편리함<br>4. 기존에 SQL문법을 그대로 적용할 수 있어 새로운 기술을 학습하지 않아도 됨 | 1. DBMS 별로 SQL 문법이 다름<br>2. 개발자가 직접 SQL문을 작성해야 함<br>3. DBMS 변경 시 SQL문을 재사용하기 어려움<br>4. 객체와 테이블간 패러다임 불일치 발생 | Mybatis 등 |
| ORM | 1. 개발자가 SQL문을 직접 작성하지 않아도 됨<br>2. SQL문이 아닌 클래스의 메서드를 통해 데이터베이스를 조작할 수 있음<br>3. DBMS에 종속적이지 않음 | 1. 직접 SQL을 작성하는 것보다 성능이 떨어질 수 있음<br>2. 사용하기 위해서는 ORM 기술을 학습해야 하는 러닝커브가 존재함<br>3. 메서드 호출로 DB 데이터를 조작하기 때문에 세밀함이 떨어짐 | JPA 등 |

## 참고

https://gmlwjd9405.github.io/2019/02/01/orm.html

https://dev-coco.tistory.com/73
