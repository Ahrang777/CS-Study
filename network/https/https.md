# [Network] HTTPS, HTTPS 동작 과정

# HTTPS란?

하이퍼 텍스트 전송 프로토콜 보안(HTTP + **Secure**)의 약자. 즉, HTTP에 데이터 암호화를 추가한 것.

HTTP와 다르게 **443번 포트(TCP/IP 포트)** 를 사용한다.  
<br/>

# HTTP vs HTTPS

HTTP의 문제점은 브라우저로 전송되는 정보(텍스트)가 암호화가 되지 않아 보안상의 위험이 있다는 것이다. 따라서 HTTPS는 `SSL(보안 소켓 계층)`을 통해 이를 해결했다.

`SSL`은 서버와 브라우저 사이에 암호화된 연결을 만들 수 있게 도와주기 때문에 서버-브라우저가 신용카드 정보나 비밀번호와 같은 민감한 정보를 주고 받을 때 도난 당하는 것을 막아준다.

그 외에도 `TSL(전송 계층 보안) 프로토콜`을 통해서도 보안을 유지한다.

`TSL`은 무결성을 제공하기 때문에 데이터의 손상을 방지하고, 사용자가 자신이 의도하는 웹사이트와 통신하고 있음을 입증하는 인증 기능도 제공한다.

### (정리)

- HTTP 통신 소켓을 SSL/TSL 프로토콜로 대체 했다.
  - 즉, `HTTP-SSL-TCL`와 통신하는 시스템으로 암호화와 증명서, 안정성 보호를 이용할 수 있게 되었다.
  - 공개키/개인키 암호화를 지원하여 데이터를 보호한다.
- HTTP에 비해 HTTPS는 암호화 통신을 하기 때문에 CPU나 메모리가 많이 필요하다는 단점이 있다.  
  <br/>

# HTTPS의 원리 - 하이브리드 암호화 방식

- **용어**
  1. 암호화: 어떤 정보를 암호화된 정보로 바꾸는 것
  2. 복호화: 암호화된 정보를 다시 원래 정보로 바꾸는 것
  3. 키: 암호화, 복호화할 때 쓰이는 비밀번호

## 대칭 키 방식이란?

: 암호화 할 때와 복호화 할 때 `같은 키(=대칭키)를 사용`하는 방식

**(장점)** 단순한 구조이기 때문에 빠르다.

**(단점)** 공동 키를 빼앗기면 복호화가 가능하기 때문에 보안에 취약하다.

## 비대칭 키(=공개 키) 방식이란?

: 암호화 할 때와 복호화 할 때 `다른 키(=공개 키, 개인 키)를 사용`하는 방식

<aside>
📖 `클라이언트->서버`

- 사용자의 데이터를 공개 키로 암호화
- 서버로 전송 (데이터를 가로채도 개인키가 없으므로 복호화 할 수 없음)
- 서버의 개인키를 통해 복호화하여 요청 처리
</aside>

**(장점)** 공통 키 방식보다 안전하다.

**(단점)** 공통 키 방식보다 느리며 리소스 소비가 크다.

## 비대칭 키 방식에서의 공통 키와 공개 키란?

**공개키**: 모두에게 공개 가능한 키 (클라이언트가 요청하면 서버가 제공)

**개인 키**: 개인에게만 공개된 키, 클라이언트-서버 구조에서는 서버가 가지고 있는 비공개키를 말한다.

⇒ 클라이언트가 공개 키를 통해 암호화를 하면 서버는 개인 키로만 복호화를 할 수 있다.

즉, 공개 키를 통해 암호화 한 내용은 공개 키를 통해 복호화하는 것이 불가능하고, 공개 키와 쌍을 이루는 개인 키를 사용해야만 복호화가 가능하기 때문에 보안 면에서 유리하다.

## 하이브리드 암호 시스템

> HTTPS는 `대칭 키 방식`과 `비대칭 키 방식` 을 혼합한 하이브리드 암호 시스템을 사용한다.

⇒ 메세지와 같은 데이터를 대칭키로 암호화 한 뒤, 이때 사용한 대칭 키는 공개 키 방식으로 암호화 하고, 이 다음부터의 통신은 이 공개 키 방식으로 생성된 키를 대칭키로 사용한다.

(이러면 서버와 클라이언트만 이를 공유할 수 있고, 속도의 문제도 해결할 수 있다.)  
<br/>

# HTTPS 동작 과정

> 클라이언트가 서버에 접속하면, 서버는 클라이언트에게 SSL 인증서 정보를 전달하고, 해당 인증서가 확인이 된 이후에 내부에 존재하는 공개키를 활용해 `세션키` 라는 것을 생성하고, 이를 활용해 통신을 시작한다. 이렇게 SSL 프로토콜을 활용해 통신을 수립하는 과정을 `SSL/TSL Handshake` 라고 한다.

1. **client hello** : 클라이언트가 서버로 hello 하면서 `SSL 버전`, `지원되는 암호 제품군`, 무작위로 생성한 `client random`을 포함한 메시지 전송
2. **server hello**: 클라이언트의 hello 메시지에 대한 응답으로 서버가 서버의 `SSL 인증서`, 서버에서 `선택한 암호 제품군`, 서버에서 생성한 무작위 바이트 문자열인 `server random`을 포함한 메시지 전송
3. **verify server certificate**: 클라이언트가 서버의 SSL 인증서를 인증서 발행 기관(CA)를 통해 검증
4. **client key exchange**: 인증 확인 후, 클라이언트는 무작위 바이트 문자열(`the premaster secret`을 공개키로 암호화 하여 전송 (이 공개키는 서버의 SSL 인증서에 포함되어 있다.)
5. **send client certificate**: 서버가 클라이언트의 인증서를 요구한다면, 서버의 인증서와 같은 방식으로 암호화를 진행하여 함께 전송
6. **verify client certificate**: 서버가 클라이언트로 받은 문자열을 개인키를 통해 해독
7. **client “finished”**: 클라이언트가 `client random`, `server random`, `the premaster secret`을 통해 대칭키로 활용할 `세션 키`를 생성 후, 세션 키로 암호화 된 `"finished"` 메시지 전송
8. **server “finished”**: 서버가 `client random`, `server random`, `the premaster secret`을 통해 대칭키로 활용할 `세션 키`를 생성 후, 세션 키로 암호화 된 `"finished"` 메시지 전송
9. **exchange messages**: handshake 완료 후, 세션 키를 이용해 메세지를 주고 받음
10. **end session**: 세션 종료 후 세션 키 폐기

---

## 참고

[http-그리고-https의 이해](https://blog.wishket.com/http-%EA%B7%B8%EB%A6%AC%EA%B3%A0-https%EC%9D%98-%EC%9D%B4%ED%95%B4/)

[[Web] HTTP와 HTTPS의 개념 및 차이점](https://mangkyu.tistory.com/98)

https://loosie.tistory.com/718#SSL/TLS_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C_(%ED%95%98%EC%9D%B4%EB%B8%8C%EB%A6%AC%EB%93%9C_%EC%95%94%ED%98%B8%ED%99%94_%EC%8B%9C%EC%8A%A4%ED%85%9C)

https://inuplace.tistory.com/1086
